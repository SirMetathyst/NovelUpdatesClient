package main

import (
	"flag"
	"fmt"
	"github.com/SirMetathyst/NovelUpdatesClient"
	"github.com/iancoleman/strcase"
	"log"
	"strings"
)

func main() {

	flagPackageName := flag.String("package", "NovelUpdatesClient", "The name of the package for the generated output")
	flagType := flag.String("type", "all", "The type of output to generate: all|noveltype|language|genres|tags|storyStatus|sortBy|orderBy")
	flag.Parse()

	b := &strings.Builder{}
	doFallthrough := false

	writeHeader(b, *flagPackageName)
	var err error

	switch *flagType {
	case "all":
		doFallthrough = true
		fallthrough
	case "noveltype":
		results, err := NovelUpdatesClient.DoFetchNovelTypeRequestWith(&NovelUpdatesClient.BasicRequester{})
		if err != nil {
			log.Fatalln(err)
		}
		writeFor("NovelType", results, b)
		if !doFallthrough {
			break
		}
		fallthrough
	case "language":
		results, err := NovelUpdatesClient.DoFetchLanguageRequestWith(&NovelUpdatesClient.BasicRequester{})
		if err != nil {
			log.Fatalln(err)
		}
		writeFor("Language", results, b)
		if !doFallthrough {
			break
		}
		fallthrough
	case "genres":
		results, err := NovelUpdatesClient.DoFetchGenresRequestWith(&NovelUpdatesClient.BasicRequester{})
		if err != nil {
			log.Fatalln(err)
		}
		writeFor("Genre", results, b)
		if !doFallthrough {
			break
		}
		fallthrough
	case "tags":
		results, err := NovelUpdatesClient.DoFetchTagsRequestWith(&NovelUpdatesClient.BasicRequester{})
		if err != nil {
			log.Fatalln(err)
		}
		writeFor("Tag", results, b)
		if !doFallthrough {
			break
		}
		fallthrough
	case "storyStatus":
		results, err := NovelUpdatesClient.DoFetchStoryStatusRequestWith(&NovelUpdatesClient.BasicRequester{})
		if err != nil {
			log.Fatalln(err)
		}
		writeFor("StoryStatus", results, b)
		if !doFallthrough {
			break
		}
		fallthrough
	case "sortBy":
		results, err := NovelUpdatesClient.DoFetchSortByRequestWith(&NovelUpdatesClient.BasicRequester{})
		if err != nil {
			log.Fatalln(err)
		}
		writeFor("SortBy", results, b)
		if !doFallthrough {
			break
		}
		fallthrough
	case "orderBy":
		results, err := NovelUpdatesClient.DoFetchOrderByRequestWith(&NovelUpdatesClient.BasicRequester{})
		if err != nil {
			log.Fatalln(err)
		}
		writeFor("OrderBy", results, b)
		if !doFallthrough {
			break
		}
	}
	if err != nil {
		log.Fatalln(err)
	}

	fmt.Println(b.String())
}

func normalisedName(n string) string {
	n = strcase.ToCamel(n)
	n = strings.Replace(n, " ", "", -1)
	n = strings.Replace(n, "-", "", -1)
	n = strings.Replace(n, "/", "", -1)
	n = strings.Replace(n, "'", "", -1)
	return n
}

func normalisedSlug(n string) string {
	n = strcase.ToCamel(n)
	n = strings.Replace(n, " ", "-", -1)
	n = strings.Replace(n, "//", "-", -1)
	n = strings.Replace(n, "'", "", -1)
	return n
}

////////////////////////////////////////////////////////

func writeHeader(b *strings.Builder, packageName string) {

	//////// Header
	b.WriteString("// Code generated by nug (NovelUpdates Generator). DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", packageName))
}

////////////////////////////////////////////////////////

func writeFor(s string, results []NovelUpdatesClient.KeyValueResult, b *strings.Builder) {

	//////// Main
	b.WriteString(fmt.Sprintf("type %s string\n\n", s))
	b.WriteString(fmt.Sprintf("// %s: Total(%d)\n", s, len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s %s = \"%s\"\n", s, normalisedName(result.Name), s, result.Value))
	}
	b.WriteString(")\n\n")

	//////// ToDisplayString
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\t%sToDisplayString = map[%s]string{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s:\"%s\",\n", s, normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// DisplayStringTo
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\tDisplayStringTo%s = map[string]%s{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":%s%s,\n", result.Name, s, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// SlugStringTo
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\tSlugStringTo%s = map[string]%s{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":%s%s,\n", normalisedSlug(result.Name), s, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	/////////// ToSlugString
	b.WriteString("var (\n")
	b.WriteString(fmt.Sprintf("\t%sToSlugString = map[%s]string{\n", s, s))

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t%s%s:\"%s\",\n", s, normalisedName(result.Name), normalisedSlug(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n")

	//////// Functions
	b.WriteString(strings.Replace(`func (s ${s}) String() string {
			return string(s)
		}
	
		func (s ${s}) SlugString() string {
			v, _ := ${s}ToSlugString[s]
			return v
		}
	
		func (s ${s}) DisplayString() string {
			v, _ := ${s}ToDisplayString[s]
			return v
		}
	
		func SlugStringTo${s}Or(s string, def ${s}) ${s} {
			if v, ok := SlugStringTo${s}[s]; ok {
				return v
			}
			return def
		}
	
		type ${s}List []${s}
	
		func (s ${s}List) StringSlice() (sl []string) {
			for _, n := range s {
				sl = append(sl, string(n))
			}
			return
		}
	
		func SlugListTo${s}List(s []string) (tl ${s}List, err error) {
			for _, n := range s {
				tli, ok := SlugStringTo${s}[n]
				if !ok {
					return nil, fmt.Errorf("error: slug %s was not found ${s} slugs", tli)
				}
				tl = append(tl, tli)
			}
			return
		}
	
		func MustSlugListTo${s}List(s []string) (${s}List) {
			list, err := SlugListTo${s}List(s)
			if err != nil {
				panic(err)
			}
			return list
		}
	`, "${s}", s, -1))
}
