package main

import (
	"flag"
	"fmt"
	"github.com/SirMetathyst/NovelUpdatesClient"
	"github.com/iancoleman/strcase"
	"log"
	"strings"
)

func main() {

	flagPackageName := flag.String("package", "NovelUpdatesClient", "The name of the package for the generated output")
	flagType := flag.String("type", "all", "The type of output to generate: all|tags|genres")
	flag.Parse()

	b := &strings.Builder{}

	switch *flagType {
	case "all":
		writeHeader(b, *flagPackageName)
		writeNovelType(b)
		writeLanguage(b)
		writeGenres(b)
		writeTags(b)
		fmt.Println(b.String())
		return
	case "noveltype":
		writeHeader(b, *flagPackageName)
		writeNovelType(b)
		fmt.Println(b.String())
		return
	case "language":
		writeHeader(b, *flagPackageName)
		writeLanguage(b)
		fmt.Println(b.String())
		return
	case "genres":
		writeHeader(b, *flagPackageName)
		writeGenres(b)
		fmt.Println(b.String())
		return
	case "tags":
		writeHeader(b, *flagPackageName)
		writeTags(b)
		fmt.Println(b.String())
		return
	}
}

func normalisedName(n string) string {
	n = strcase.ToCamel(n)
	n = strings.Replace(n, " ", "", -1)
	n = strings.Replace(n, "-", "", -1)
	n = strings.Replace(n, "/", "", -1)
	n = strings.Replace(n, "'", "", -1)
	return n
}

////////////////////////////////////////////////////////

func writeHeader(b *strings.Builder, packageName string) {

	//////// Header
	b.WriteString("// Code generated by nug (NovelUpdates Generator). DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", packageName))
}

////////////////////////////////////////////////////////

func writeNovelType(b *strings.Builder) {

	results, err := NovelUpdatesClient.DoFetchNovelTypeRequest()
	if err != nil {
		log.Fatalln(err)
	}

	//////// NovelType
	b.WriteString("type NovelType string\n\n")
	b.WriteString(fmt.Sprintf("// NovelType: Total(%d)\n", len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tNovelType%s NovelType = \"%s\"\n", normalisedName(result.Name), result.Value))
	}

	b.WriteString(")\n\n")

	//////// NovelTypeToName
	b.WriteString("var (\n")
	b.WriteString("\tNovelTypeToName = map[NovelType]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tNovelType%s:\"%s\",\n", normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	///////// NameToNovelType
	b.WriteString("var (\n")
	b.WriteString("\tNameToNovelType = map[string]NovelType{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":NovelType%s,\n", result.Name, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n")
}

////////////////////////////////////////////////////////

func writeLanguage(b *strings.Builder) {

	results, err := NovelUpdatesClient.DoFetchLanguageRequest()
	if err != nil {
		log.Fatalln(err)
	}

	//////// Language
	b.WriteString("type Language string\n\n")
	b.WriteString(fmt.Sprintf("// Language: Total(%d)\n", len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tLanguage%s Language = \"%s\"\n", normalisedName(result.Name), result.Value))
	}

	b.WriteString(")\n\n")

	//////// LanguageToName
	b.WriteString("var (\n")
	b.WriteString("\tLanguageToName = map[Language]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tLanguage%s:\"%s\",\n", normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	///////// NameToLanguage
	b.WriteString("var (\n")
	b.WriteString("\tNameToLanguage = map[string]Language{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":Language%s,\n", result.Name, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n")
}

////////////////////////////////////////////////////////

func writeGenres(b *strings.Builder) {

	results, err := NovelUpdatesClient.DoFetchGenresRequest()
	if err != nil {
		log.Fatalln(err)
	}

	//////// Genre
	b.WriteString("type Genre string\n\n")
	b.WriteString(fmt.Sprintf("// Genre: Total(%d)\n", len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tGenre%s Genre = \"%s\"\n", normalisedName(result.Name), result.Value))
	}

	b.WriteString(")\n\n")

	//////// GenreToName
	b.WriteString("var (\n")
	b.WriteString("\tGenreToName = map[Genre]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tGenre%s:\"%s\",\n", normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	///////// NameToGenre
	b.WriteString("var (\n")
	b.WriteString("\tNameToGenre = map[string]Genre{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":Genre%s,\n", result.Name, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n")
}

////////////////////////////////////////////////////////

func writeTags(b *strings.Builder) {

	results, err := NovelUpdatesClient.DoFetchTagsRequest()
	if err != nil {
		log.Fatalln(err)
	}

	//////// Tag
	b.WriteString("type Tag string\n\n")
	b.WriteString(fmt.Sprintf("// Tag: Total(%d)\n", len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tTag%s Tag = \"%s\"\n", normalisedName(result.Name), result.Value))
	}

	b.WriteString(")\n\n")

	//////// TagToName
	b.WriteString("var (\n")
	b.WriteString("\tTagToName = map[Tag]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tTag%s:\"%s\",\n", normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	///////// NameToTag
	b.WriteString("var (\n")
	b.WriteString("\tNameToTag = map[string]Tag{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":Tag%s,\n", result.Name, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n")
}
