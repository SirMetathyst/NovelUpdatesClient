package main

import (
	"flag"
	"fmt"
	"github.com/SirMetathyst/NovelUpdatesClient"
	"github.com/iancoleman/strcase"
	"log"
	"strings"
)

func main() {

	flagPackageName := flag.String("package", "NovelUpdatesClient", "The name of the package for the generated output")
	flagType := flag.String("type", "all", "The type of output to generate: all|tags|genres")
	flag.Parse()

	b := &strings.Builder{}

	switch *flagType {
	case "all":
		writeHeader(b, *flagPackageName)
		writeNovelType(b)
		writeLanguage(b)
		writeGenres(b)
		writeTags(b)
		fmt.Println(b.String())
		return
	case "noveltype":
		writeHeader(b, *flagPackageName)
		writeNovelType(b)
		fmt.Println(b.String())
		return
	case "language":
		writeHeader(b, *flagPackageName)
		writeLanguage(b)
		fmt.Println(b.String())
		return
	case "genres":
		writeHeader(b, *flagPackageName)
		writeGenres(b)
		fmt.Println(b.String())
		return
	case "tags":
		writeHeader(b, *flagPackageName)
		writeTags(b)
		fmt.Println(b.String())
		return
	}
}

func normalisedName(n string) string {
	n = strcase.ToCamel(n)
	n = strings.Replace(n, " ", "", -1)
	n = strings.Replace(n, "-", "", -1)
	n = strings.Replace(n, "/", "", -1)
	n = strings.Replace(n, "'", "", -1)
	return n
}

////////////////////////////////////////////////////////

func writeHeader(b *strings.Builder, packageName string) {

	//////// Header
	b.WriteString("// Code generated by nug (NovelUpdates Generator). DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", packageName))
}

////////////////////////////////////////////////////////

func writeNovelType(b *strings.Builder) {

	results, err := NovelUpdatesClient.DoFetchNovelTypeRequestWith(&NovelUpdatesClient.BasicRequester{})
	if err != nil {
		log.Fatalln(err)
	}

	//////// NovelType
	b.WriteString("type NovelType string\n\n")
	b.WriteString(fmt.Sprintf("// NovelType: Total(%d)\n", len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tNovelType%s NovelType = \"%s\"\n", normalisedName(result.Name), result.Value))
		//b.WriteString(fmt.Sprintf("\tNovelType%s = \"%s\"\n", normalisedName(result.Name), result.Value))
	}

	b.WriteString(")\n\n")

	//////// NovelTypeList
	b.WriteString(`type NovelTypeList []NovelType

func (s NovelTypeList) StringSlice() (ss []string) {
	for _, n := range s {
		ss = append(ss, string(n))
	}
	return
}

func SlugListToNovelTypeList(s []string) (ntl NovelTypeList, err error) {
	for _, n := range s {
		nt, ok := SlugToNovelType[n]
		if !ok {
			return nil, fmt.Errorf("error: slug %s was not found in novel type slugs", n)
		}
		ntl = append(ntl, nt)
	}
	return
}
`)

	//////// NovelTypeToName
	b.WriteString("var (\n")
	b.WriteString("\tNovelTypeToName = map[NovelType]string{\n")
	//b.WriteString("\tNovelTypeToName = map[string]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tNovelType%s:\"%s\",\n", normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	///////// NameToNovelType
	b.WriteString("var (\n")
	b.WriteString("\tNameToNovelType = map[string]NovelType{\n")
	//b.WriteString("\tNameToNovelType = map[string]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":NovelType%s,\n", result.Name, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	///////// SlugToNovelType
	b.WriteString("var (\n")
	b.WriteString("\tSlugToNovelType = map[string]NovelType{\n")
	//b.WriteString("\tSlugToNovelType = map[string]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":NovelType%s,\n", strings.ToLower(strings.Replace(result.Name, " ", "-", -1)), normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n")
}

////////////////////////////////////////////////////////

func writeLanguage(b *strings.Builder) {

	results, err := NovelUpdatesClient.DoFetchLanguageRequestWith(&NovelUpdatesClient.BasicRequester{})
	if err != nil {
		log.Fatalln(err)
	}

	//////// Language
	b.WriteString("type Language string\n\n")
	b.WriteString(fmt.Sprintf("// Language: Total(%d)\n", len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tLanguage%s Language = \"%s\"\n", normalisedName(result.Name), result.Value))
		//b.WriteString(fmt.Sprintf("\tLanguage%s = \"%s\"\n", normalisedName(result.Name), result.Value))
	}

	b.WriteString(")\n\n")

	//////// NovelTypeList
	b.WriteString(`type LanguageList []Language

func (s LanguageList) StringSlice() (ss []string) {
	for _, n := range s {
		ss = append(ss, string(n))
	}
	return
}

func SlugListToLanguageList(s []string) (ll LanguageList, err error) {
	for _, n := range s {
		l, ok := SlugToLanguage[n]
		if !ok {
			return nil, fmt.Errorf("error: slug %s was not found in language slugs", l)
		}
		ll = append(ll, l)
	}
	return
}
`)

	//////// LanguageToName
	b.WriteString("var (\n")
	b.WriteString("\tLanguageToName = map[Language]string{\n")
	//b.WriteString("\tLanguageToName = map[string]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tLanguage%s:\"%s\",\n", normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	///////// NameToLanguage
	b.WriteString("var (\n")
	b.WriteString("\tNameToLanguage = map[string]Language{\n")
	//b.WriteString("\tNameToLanguage = map[string]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":Language%s,\n", result.Name, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	///////// SlugToNovelType
	b.WriteString("var (\n")
	b.WriteString("\tSlugToLanguage = map[string]Language{\n")
	//b.WriteString("\tSlugToLanguage = map[string]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":Language%s,\n", strings.ToLower(strings.Replace(result.Name, " ", "-", -1)), normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n")
}

////////////////////////////////////////////////////////

func writeGenres(b *strings.Builder) {

	results, err := NovelUpdatesClient.DoFetchGenresRequestWith(&NovelUpdatesClient.BasicRequester{})
	if err != nil {
		log.Fatalln(err)
	}

	//////// Genre
	b.WriteString("type Genre string\n\n")
	b.WriteString(fmt.Sprintf("// Genre: Total(%d)\n", len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tGenre%s Genre = \"%s\"\n", normalisedName(result.Name), result.Value))
		//b.WriteString(fmt.Sprintf("\tGenre%s = \"%s\"\n", normalisedName(result.Name), result.Value))
	}
	b.WriteString(")\n\n")

	////// GenreList
	b.WriteString(`type GenreList []Genre
	
	func (s GenreList) StringSlice() (ss []string) {
		for _, n := range s {
			ss = append(ss, string(n))
		}
		return
	}
	
	func SlugListToGenreList(s []string) (gl GenreList, err error) {
		for _, n := range s {
			g, ok := SlugToGenre[n]
			if !ok {
				return nil, fmt.Errorf("error: slug %s was not found in genre slugs", g)
			}
			gl = append(gl, g)
		}
		return
	}
	`)

	//////// GenreToName
	b.WriteString("var (\n")
	b.WriteString("\tGenreToName = map[Genre]string{\n")
	//b.WriteString("\tGenreToName = map[string]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tGenre%s:\"%s\",\n", normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	///////// NameToGenre
	b.WriteString("var (\n")
	b.WriteString("\tNameToGenre = map[string]Genre{\n")
	//b.WriteString("\tNameToGenre = map[string]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":Genre%s,\n", result.Name, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	///////// SlugToGenre
	b.WriteString("var (\n")
	b.WriteString("\tSlugToGenre = map[string]Genre{\n")
	//b.WriteString("\SlugToGenre = map[string]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":Genre%s,\n", strings.ToLower(strings.Replace(result.Name, " ", "-", -1)), normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n")
}

////////////////////////////////////////////////////////

func writeTags(b *strings.Builder) {

	results, err := NovelUpdatesClient.DoFetchTagsRequestWith(&NovelUpdatesClient.BasicRequester{})
	if err != nil {
		log.Fatalln(err)
	}

	//////// Tag
	//b.WriteString("type Tag string\n\n")
	b.WriteString(fmt.Sprintf("// Tag: Total(%d)\n", len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		//b.WriteString(fmt.Sprintf("\tTag%s Tag = \"%s\"\n", normalisedName(result.Name), result.Value))
		b.WriteString(fmt.Sprintf("\tTag%s = \"%s\"\n", normalisedName(result.Name), result.Value))
	}

	b.WriteString(")\n\n")

	//////// TagToName
	b.WriteString("var (\n")
	//b.WriteString("\tTagToName = map[Tag]string{\n")
	b.WriteString("\tTagToName = map[string]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tTag%s:\"%s\",\n", normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	///////// NameToTag
	b.WriteString("var (\n")
	//b.WriteString("\tNameToTag = map[string]Tag{\n")
	b.WriteString("\tNameToTag = map[string]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":Tag%s,\n", result.Name, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")\n")
}
