package main

import (
	"flag"
	"fmt"
	"github.com/SirMetathyst/NovelUpdatesClient"
	"github.com/iancoleman/strcase"
	"log"
	"strings"
)

func normalisedName(n string) string {
	n = strcase.ToCamel(n)
	n = strings.Replace(n, " ", "", -1)
	n = strings.Replace(n, "-", "", -1)
	n = strings.Replace(n, "/", "", -1)
	n = strings.Replace(n, "'", "", -1)
	return n
}

func writeHeader(b *strings.Builder, packageName string) {

	//////// Header
	b.WriteString("// Code generated by genrec. DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", packageName))
}

func writeGenres(b *strings.Builder) {

	results, err := NovelUpdatesClient.Genres()
	if err != nil {
		log.Fatalln(err)
	}

	//////// Genres
	b.WriteString("type Genre string\n\n")
	b.WriteString(fmt.Sprintf("// Genres: Total(%d)\n", len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tGenre%s Genre = \"%s\"\n", normalisedName(result.Name), result.Value))
	}

	b.WriteString(")\n")

	//////// GenreToName
	b.WriteString("var (\n")
	b.WriteString("\tGenreToName = map[Genre]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tGenre%s:\"%s\",\n", normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	///////// NameToGenre
	b.WriteString("var (\n")
	b.WriteString("\tNameToGenre = map[string]Genre{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":Genre%s,\n", result.Name, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")")
}

func writeTags(b *strings.Builder) {

	results, err := NovelUpdatesClient.Tags()
	if err != nil {
		log.Fatalln(err)
	}

	//////// Tags
	b.WriteString("type Tag string\n\n")
	b.WriteString(fmt.Sprintf("// Tags: Total(%d)\n", len(results)))
	b.WriteString("const (\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tTag%s Tag = \"%s\"\n", normalisedName(result.Name), result.Value))
	}

	b.WriteString(")\n")

	//////// TagToName
	b.WriteString("var (\n")
	b.WriteString("\tTagToName = map[Tag]string{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\tTag%s:\"%s\",\n", normalisedName(result.Name), result.Name))
	}

	b.WriteString("}\n")
	b.WriteString(")\n\n")

	///////// NameToTag
	b.WriteString("var (\n")
	b.WriteString("\tNameToTag = map[string]Tag{\n")

	for _, result := range results {
		b.WriteString(fmt.Sprintf("\t\"%s\":Tag%s,\n", result.Name, normalisedName(result.Name)))
	}

	b.WriteString("}\n")
	b.WriteString(")")
}

func main() {

	flagPackageName := flag.String("package", "NovelUpdatesClient", "The name of the package for the generated output")
	flagType := flag.String("type", "all", "The type of output to generate: all|tags|genres")
	flag.Parse()

	b := &strings.Builder{}

	switch *flagType {
	case "all":
		writeHeader(b, *flagPackageName)
		writeGenres(b)
		writeTags(b)
		fmt.Println(b.String())
		return
	case "genres":
		writeHeader(b, *flagPackageName)
		writeGenres(b)
		fmt.Println(b.String())
		return
	case "tags":
		writeHeader(b, *flagPackageName)
		writeTags(b)
		fmt.Println(b.String())
		return
	}
}
